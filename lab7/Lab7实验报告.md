#Lab7实验报告
计23班 杨煜 2011010312

##实验0：填写已有实验
按照要求填写Lab1-6的已有代码。
对已有代码的改进为：
将trap.c中trap\_dispatch中时钟中断函数调用改为run\_timer\_list()。

##实验1:理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
可以使用一个信号灯变量mutex保证其对共享变量state_sema写的互斥性，每个哲学家用一个信号灯表示自己请求的叉子是否是可用的。如果他想拿起叉子但拿不到时，该线程进入该信号灯的等待队列，当被唤醒并获得cpu时，即叉子已可以使用时，就执行，即开始就餐；放下叉子时尝试唤醒两边的哲学家进行就餐。

###请在实验报告中给出内核级信号量的设计描述，并说出其大致执行流流程。

信号灯的基本原理是一个表示空闲的资源使用权数量的数字和表示等待资源使用权的进程队列，其基本操作是请求使用权的P操作和释放使用权的V操作。

P操作基本过程是：如果有使用权剩余，则获得之（修改计数）并返回继续执行，否则进程进入该信号灯的等待队列并调用schedule交出cpu，直到被其他进程唤醒时进入就绪队列，获得cpu使用权时从schedule后开始，离开等待队列并继续操作。

V操作的基本过程是：如果等待队列不为空则唤醒队列中第一个等待进程，放入就绪队列，否则空闲资源计数加一即可。


###请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

用户态实现的主要问题是没有权限，不能直接操作进程状态、进行进程切换和调度，无法使用特权指令如cli。不过用户态也有对应的解决方法，即把信号灯机制用系统调用包装起来提供给用户。或者可以开发一个用户态的库来实现信号灯机制，在权限不够的地方就使用系统调用完成，换句话说就是把现有的信号灯相关代码写到用户库里，其中需要特殊权限的操作改为系统调用。

##实验2:完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

利用管程解决该哲学家就餐问题。

管程管理的数据只包含state\_condvar，各个哲学家的请求也通过管程互斥化，每个哲学家有一个管程中的条件变量表示他所请求的叉子目前是否在就绪状态。与上一种信号量的实现的区别仅仅是把mutex和信号灯列表以管程的mutex和条件变量列表的形式重新表达，其运行机制也基本相同。

###请在实验报告中给出内核级条件变量的设计描述，并说明其大致执行流流程。

条件变量结构里包含着一个信号灯，含有等待该条件变量变为真的进程列表，是管程机制的一部分。

管程是各个进程访问某数据的通用接口，由于它同一时刻只受理一个进程的请求，因此使用它可以完成对数据的互斥共享。管程机制中有5种进程：

- 等待进入管程的进程（mutex等待列表）
- 正在占用管程的进程，
- 已进入管程但是因为等待某个条件变量而在沉睡的进程（某个cv的等待列表）
- 已进入管程但是在运行中因为唤醒其他进程而交出了管程占用权（管程只受理一个进程的请求的限制）
- 进入沉睡的进程（next等待列表）。

管程机制基本就是在这5种状态之间的转换：触发条件变量（cond_signal）时如该条件变量有进程等待则唤醒他而自己进入next等待队列；等待条件变量（cond_wait）时唤醒next或mutex列表中的某个进程而自己进入该条件变量的等待队列。

###请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

实现过程与上述用户态的信号灯机制是相同的。

###设计实现过程
按照注释的提示，按照课堂上所学的管程的概念和原理，并按照ucorelab中monitor结构体和condvar结构体中各变量的定义实现了管程的机制。

##总结
Lab7中涉及到的知识点：- 进程状态转移模型--对应代码中的wait.[ch]中的队列，应用在信号灯中
- 信号灯机制--对应sem.[ch]中的定义，在check_sync.c中用它实现了哲学家就餐问题第一种解法

- 以信号灯机制为基础的管程机制--对应monitor.[ch]中的定义，在check_sync.c中用它实现了哲学家就餐问题的第二种解法
- 临界区和互斥锁的概念，在实验中由信号灯实现

Lab7中未涉及到的知识点:

- 自旋锁- 基于软件的同步互斥解决方案